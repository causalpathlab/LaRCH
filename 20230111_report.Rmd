# Tree-spike-slab
- Yichen Zhang
```{r setup, message=FALSE}
library(aricode)
library(data.table)
library(dplyr)
library(knitr)
source("util.R")
```

## Data Simulation
```{r data, eval = F}
# ' SoftMax Operation
#' @param par vector
#' @return softmax(vector)
softmax <- function(par){
  n.par <- length(par)
  par1 <- sort(par, decreasing = TRUE)
  Lk <- par1[1]
  for (k in 1:(n.par-1)) {
    Lk <- max(par1[k+1], Lk) + log1p(exp(-abs(par1[k+1] - Lk))) 
  }
  val <- exp(par - Lk)
  return(val)
}

#' Perfect Binary Tree-based convolution matrix
#' @param D tree depth
#' @return S adjacency matrix (#leaves x #tree nodes)
pbt.adj <- function(D, .signed = FALSE) {
    if(D < 2) return(matrix(1))
    .N <- 2^D - 1
    .nodes <- 1:.N
    .leaves <- 1:(2^(D-1))
    .bot <- (2^(D-1)):.N
    .col <- .bot
    .row <- .leaves
    .elem <- rep(1, length(.leaves))
    for(d in seq(1,D-1)){
        .bot <- floor(.bot/2)
        if(.signed){
            .new.elem <- 2*ceiling(.leaves/2^(d-1)) %% 2 - 1
        } else {
            .new.elem <- rep(1, length(.leaves))
        }
        .elem <- c(.elem, .new.elem)
        .col <- c(.col, .bot)
        .row <- c(.row, .leaves)
    }
    sparseMatrix(i = .row,
                 j = .col,
                 x = .elem)
}

#' Simulate three based data
#' @param N #cells
#' @param G #genes
#' @param g #anchor genes
#' @param D_tree tree depth
#' @param gamma0
#' @param alpha0
#' @param data.file
#' @return list X (#cell x #genes), anchor_gene_idx, A (tree adjacency matrix) 

sim_data <- function(N, G, g, D_tree, data.file, gamma0 = 50, alpha0 = 5){
  
  if(file.exists(data.file)){
    return(readRDS(data.file))
  }
  # Construct adjacency matrix for tree with depth of Tr
  A <- pbt.adj(D_tree)
  dim(A)[1] -> T #leaves/topics 
  dim(A)[2] -> Tr #tree nodes
  # Sample gene selection probability vector \pi_{jg} from Dirichlet
  #gamma0 <- 50
  pi <- rdirichlet(n=Tr, alpha=gamma0 * rep(1/g, g))
  # Sample node-specific effect size (positive)
  beta_node <- rgamma(n=Tr, shape=1)
  # Aggregate tree-node-specific topics to construct beta
  beta <- A %*% (beta_node * pi)
  # Sample topic proportions from Dirichlet
  # alpha0 <- 5
  theta <- rdirichlet(n = N, alpha = alpha0 * rep(1/T, T))
  # Aggregate topic-specific gene activities
  rho <- theta %*% beta
  # Sample X from multinomial
  D <- rbeta(N, 1,1) # sequencing depth
  X_anchor_gene <- matrix(0, nrow=N, ncol=g)
  for(i in 1:N){   
    X_anchor_gene[i,] <- rmultinom(1, g, D[i] *  softmax(rho[i,]))
  }
  # Assign the anchor genes to X
  X <- matrix(0, nrow=N, ncol=G)
  anchor_gene_idx <- sample(G, g, replace=FALSE)
  for(j in g){
    X[,anchor_gene_idx[j]] <- X_anchor_gene[,j] 
  }
  # parameters
  param_list <- list(N = N, G = G, g = g,
                    D_tree = D_tree,
                    gamma0 = gamma0, 
                    alpha0 = alpha0)

  res <- list(X = X, X_anchor_gene = X_anchor_gene, A = A,
              anchor_gene_idx = anchor_gene_idx,
              theta = theta, beta = beta, rho = rho, D = D,
              param_list = param_list)
  saveRDS(res, data.file)
  return(res)
}

seed <- 123
set.seed(seed)

N <- 5000
G <- g <- 1000
D_tree <- 5
dat <- sim_data(N, G, g, D_tree, "data/sim_tree.rda")
```


## Model: EPOCH = 2000, Tree Depth = 5, KL weight = 0.1, pip = 1
```{r log}
logs <- fread("logs/tree_spike_slab_ep2000_treeD5_bs128_lr0.01_train_size1_pip1.0_kl0.1_klbeta1_seed66/20230111/metrics.csv")
logs %>% select("elbo_train", "train_loss_epoch", "epoch", "kl_beta_train", "kl_local_train", "reconstruction_loss_train") %>% na.omit() -> logs

plot(logs$elbo_train ~ logs$epoch)
plot(logs$train_loss_epoch ~ logs$epoch)
plot(logs$kl_beta_train ~ logs$epoch)
plot(logs$kl_local_train ~ logs$epoch)
plot(logs$reconstruction_loss_train ~ logs$epoch)
```

## theta^hat and theta 
```{r heatmap}
model_path <-"models/tree_spike_slab_ep2000_treeD5_bs128_lr0.01_train_size1_pip1.0_kl0.1_klbeta1_seed66"

topics_est <- as.matrix(fread(paste0(model_path, "/topics.csv")), rownames = 1)

apply(topics_est, 1, which.max) %>% table() %>% kable()
heatmap(topics_est)


dat <- readRDS("data/sim_tree.rda")
apply(dat$theta, 1, softmax) -> theta

apply(theta, 2, which.max) %>% table() %>% kable
t(theta) %>% heatmap()
```

## Normalized Mutual Information
```{r NMI}
### Normalized Mutual Information
NMI(paste0("topic", c(apply(topics_est, 1, which.max))), c(t(apply(theta, 2, which.max))))
```

## Two ill-conditioned Models

### Sparse Model leads to mode collapsing: KL weight = 0.1, pip = 0.1
```{r ill1}
model_path <-"models/tree_spike_slab_ep2000_treeD5_bs128_lr0.01_train_size1_pip0.1_kl0.1_klbeta1_seed66"

topics_est <- as.matrix(fread(paste0(model_path, "/topics.csv")), rownames = 1)

apply(topics_est, 1, which.max) %>% table() %>% kable()
heatmap(topics_est)
```

### Too big weight on KL leads to mode collapsing: KL weight = 0.5, pip = 1
```{r ill2}
model_path <-"models/tree_spike_slab_ep2000_treeD5_bs128_lr0.01_train_size1_pip1.0_kl0.5_klbeta1_seed66"

topics_est <- as.matrix(fread(paste0(model_path, "/topics.csv")), rownames = 1)

apply(topics_est, 1, which.max) %>% table() %>% kable()
heatmap(topics_est)
```

